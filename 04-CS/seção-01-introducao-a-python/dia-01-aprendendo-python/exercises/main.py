2 * 3  # sa√≠da: 6
2 + 3  # sa√≠da: 5
3 / 2  # sa√≠da: 1.5

square_root = 25 ** (1/2)  # raiz quadrada de 25. O operador `**` significa "elevado a"

print(square_root + 1)  # sa√≠da: 6.0

counter = 0
# counter++  # esse c√≥digo vai falhar

# original
counter = counter + 1

# simplificado
counter += 1

3 // 2  # sa√≠da: 1

3 / 2  # sa√≠da: 1.5

# Anota a√≠ ‚úèÔ∏è: O m√©todo type(operando) corresponde ao operador typeof operando do JavaScript.

# De olho na dicaüëÄ: Assim como qualquer linguagem de programa√ß√£o, Python tamb√©m possui uma grande 
# quantidade de comandos que precisamos aprender. Para nos ajudar nessa tarefa, podemos digitar help() 
# dentro da linha de comandos do Python que ele nos dar√° detalhes do comando passado por par√¢metro.

help(list)


# O comando help() tamb√©m pode ser utilizado em cl√°usulas if ou for, desde que colocado entre aspas e 
# para sair de dentro do comando, basta apertar a tecla q.

help("if")


# Anota a√≠ ‚úèÔ∏è: uma lista √© uma sequ√™ncia mut√°vel e ordenada de elementos. Ela pode armazenar elementos 
# heterog√™neos, ter seu tamanho vari√°vel e crescer √† medida que itens s√£o adicionados.

fruits = ["laranja", "ma√ß√£", "uva", "abacaxi"]  # elementos s√£o definidos separados por v√≠rgula, envolvidos por colchetes

fruits[0]  # o acesso √© feito por √≠ndices iniciados em 0

fruits[-1]  # o acesso tamb√©m pode ser negativo

fruits.append("banana")  # adicionando uma nova fruta

fruits.remove("abacaxi")  # removendo uma fruta

fruits.extend(["pera", "mel√£o", "kiwi"])  # acrescenta uma lista de frutas a lista original

fruits.index("ma√ß√£")  # retorna o √≠ndice onde a fruta est√° localizada, neste caso, 1

fruits.sort()  # ordena a lista de frutas


# Tuplas (tuple)
# S√£o similares a listas, por√©m n√£o podem ser modificados durante a execu√ß√£o do programa.

user = ("Will", "Marcondes", 42)  # elementos s√£o definidos separados por v√≠rgula, envolvidos por par√™nteses

user[0]  # acesso tamb√©m por √≠ndices


# Conjuntos (set)
# Um conjunto √© uma cole√ß√£o de elementos √∫nicos e n√£o ordenados. Conjuntos implementam opera√ß√µes de uni√£o, 
# intersec√ß√£o e outras.

permissions = {"member", "group"}  # elementos separados por v√≠rgula, envolvidos por chaves

permissions.add("root")  # adiciona um novo elemento ao conjunto

permissions.add("member")  # como o elemento j√° existe, nenhum novo item √© adicionado ao conjunto

permissions.union({"user"})  # retorna um conjunto resultado da uni√£o

permissions.intersection({"user", "member"})  # retorna um conjunto resultante da intersec√ß√£o dos conjuntos

permissions.difference({"user"})  # retorna a diferen√ßa entre os dois conjuntos


# Conjuntos imut√°veis (frozenset)
# √â uma varia√ß√£o do set, por√©m imut√°vel, ou seja, seus elementos n√£o podem ser modificados durante a 
# execu√ß√£o do programa.

permissions = frozenset(["member", "group"])  # assim como o set, qualquer estrutura iter√°vel pode ser utilizada para criar um frozenset

permissions.union({"user"})  # novos conjuntos imut√°veis podem ser criados √† partir do original, mas o mesmo n√£o pode ser modificado

permissions.intersection({"user", "member"})  # retorna um conjunto resultante da intersec√ß√£o dos conjuntos

permissions.difference({"user"})  # retorna a diferen√ßa entre os dois conjuntos


# Dicion√°rios (dict)
# Estrutura que associa uma chave a um determinado valor. √â a representa√ß√£o do t√£o famoso objeto que 
# utilizamos em JavaScript.

people_by_id = {1: "Maria", 2: "Fernanda", 3: "Felipe"}  # elementos no formato "chave: valor" separados por v√≠rgula, envolvidos por chaves

people_by_name = {"Maria": 1, "Fernanda": 2, "Felipe": 3}  # outro exemplo, dessa vez usando strings como chaves. As aspas s√£o necess√°rias para que o Python n√£o ache que `Maria`, `Fernanda` e `Felipe` sejam vari√°veis.

# elementos s√£o acessados por suas chaves
people_by_id[1]  # sa√≠da: Maria

# elementos podem ser removidos com a palavra chave del
del people_by_id[1]
people_by_id.items()  # dict_items([(2, "Fernanda"), (3, "Felipe")])
# √© retornada uma cole√ß√£o iter√°vel de tuplas contendo chaves e valores


# Range (range)
# Estrutura capaz de gerar uma sequ√™ncia num√©rica de um valor inicial at√© um valor final, modificando seu 
# valor de acordo com o passo (step) definido. Pode ser declarado como range( [start], [stop], [step] ), em 
# que start e step podem ser omitidos, possuindo valores iniciais iguais a 0 e 1 respectivamente.
# Anota a√≠ ‚úèÔ∏è: O stop n√£o √© inclu√≠do na sequ√™ncia, portanto, caso queira uma sequ√™ncia de 1 at√© 10 a chamada 
# dever√° ser range(1, 11)
# Seus valores s√£o criados √† medida que esta sequ√™ncia √© percorrida.

# vamos converter o range em uma lista para ajudar na visualiza√ß√£o

# definimos somente o valor de parada
list(range(5))  # sa√≠da: [0, 1, 2, 3, 4]

# definimos o valor inicial e o de parada
list(range(1, 6))  # sa√≠da: [1, 2, 3, 4, 5]

# definimos valor inicial, de parada e modificamos o passo para 2
list(range(1, 11, 2))  # sa√≠da: [1, 3, 5, 7, 9]

# podemos utilizar valores negativos para as entradas tamb√©m
list(range(10, 0, -1))  # sa√≠da: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

# estruturas condicionais

position = ""
if salary <= 2000:
    position = "estagi√°rio"
elif 2000 < salary <= 5800:
    position = "j√∫nior"
elif 5800 < salary <= 7500:
    position = "pleno"
elif 7500 < salary <= 10500:
    position = "senior"
else:
    position = "l√≠der"


# Em alguns casos, em que n√£o seja prejudicada a legibilidade, podemos criar estruturas de mapeamento 
# (dicts) para simplificar o aninhamento de condicionais. Como o exemplo a segui

key = "id"
from_to = {
    "id": "identifier",
    "mail": "email",
    "lastName": "last_name",
}
from_to[key]

# FOR
# Imagine um sistema que fa√ßa a listagem de restaurantes. Estes restaurantes possuem uma nota 
# proveniente da avalia√ß√£o dos seus clientes.
restaurants = [
    {"name": "Restaurante A", "nota": 4.5},
    {"name": "Restaurante B", "nota": 3.0},
    {"name": "Restaurante C", "nota": 4.2},
    {"name": "Restaurante D", "nota": 2.3},
]
# Quando um cliente pede a listagem de restaurantes, ele pode escolher filtrar o resultado de acordo
#  com a nota. Essa filtragem pode ocorrer percorrendo a lista de restaurantes ou criando uma nova 
# lista com somente aqueles que atendem ao filtro, assim como mostra o exemplo abaixo:

filtered_restaurants = []
min_rating = 3.0
for restaurant in restaurants:
    if restaurant["nota"] > min_rating:
        filtered_restaurants.append(restaurant)
print(filtered_restaurants)  # imprime a lista de restaurantes, sem o B e D

# Dado que a maior parte do tempo estamos percorrendo estruturas, os criadores do Python decidiram que
#  o for each seria o la√ßo de repeti√ß√£o principal na linguagem.
# Para cada repeti√ß√£o do nosso la√ßo, um novo elemento da estrutura iter√°vel √© atribu√≠do a vari√°vel de 
# itera√ß√£o. No exemplo acima, vemos que a cada itera√ß√£o um novo restaurante √© colocado na vari√°vel 
# restaurant.

# Anota ai ‚úèÔ∏è: Em alguns casos, podemos ainda querer percorrer uma sequ√™ncia num√©rica, e para isto 
# iteramos sobre a estrutura de dados range.

for index in range(5):
    print(index)

# Al√©m de listas, v√°rias outras estruturas s√£o iter√°veis, como strings (str), tuplas (tuple), 
# conjuntos (set), dicion√°rios (dict) e at√© mesmo arquivos.

# Compreens√£o de lista (list comprehension)

min_rating = 3.0
filtered_restaurants = [
    restaurant
    for restaurant in restaurants
    if restaurant["nota"] > min_rating
]
print(filtered_restaurants)  # imprime a lista de restaurantes, sem o B e D


# A compreens√£o de listas √© declarada da mesma maneira que uma lista comum, por√©m no lugar dos 
# elementos n√≥s colocamos a itera√ß√£o que vai gerar os elementos da nova lista.

# De olho na dicaüëÄ: √â poss√≠vel filtrar esses elementos utilizando o if.

# Poder√≠amos listar tamb√©m somente o nome dos restaurantes, veja o exemplo abaixo:

# min_rating = 3.0
filtered_restaurants = [restaurant["name"]]  # aqui pedimos somente o nome do restaurante
#                        for restaurant in restaurants
#                        if restaurant["nota"] > min_rating]
# print(filtered_restaurants)  # imprime a lista de restaurantes, sem o B e D


# A compreens√£o de listas tamb√©m funciona com listas de strings. A seguinte cria uma nova lista de 
# strings com os nomes que cont√©m a letra ‚Äòa‚Äô.

names_list = ['Duda', 'Rafa', 'Cris', 'Yuri']
new_names_list = [name for name in names_list if 'a' in name]

# Aqui o for percorre cada nome em "names_list", verifica se existe a letra "a" nele,
# o adiciona √† vari√°vel "name", e ent√£o gera nossa nova lista "new_names_list"
print(new_names_list)

# Sa√≠da
['Duda', 'Rafa']


# O exemplo a seguir usa uma compreens√£o de listas para criar uma lista com o quadrado dos 
# n√∫meros entre 1 e 10.

quadrados = [x*x for x in range(11)]
print(quadrados)

# Sa√≠da
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# Isto √© equivalente √†s opera√ß√µes de map e filter em JavaScript.


# WHILE
# fibonacci

n = 10
last, next = 0, 1
while last < n:
    print(last)
    last, next = next, last + next

# O la√ßo de repeti√ß√£o while acontecer√° enquanto a condi√ß√£o for satisfeita.

# Aviso: Tenha cuidado ao manipular a vari√°vel presente na condicional ou entrar√° em uma repeti√ß√£o
#  infinita.
# No exemplo anterior, estamos imprimindo os elementos da sequ√™ncia at√© que atinja o valor 10.
# Neste caso, foi utilizado um truque chamado atribui√ß√£o m√∫ltipla. Isto √©, atribui√ß√£o de v√°rios 
# valores a m√∫ltiplas vari√°veis ao mesmo tempo.

# De olho na dicaüëÄ: Este truque pode ser utilizado tamb√©m para fazer a troca de valores entre 
# vari√°veis: a, b = b, a.

# enumerate
# Em Python, um loop for geralmente √© escrito como um loop sobre um objeto iter√°vel. 
# Isso significa que voc√™ n√£o precisa de uma vari√°vel de contagem para acessar itens no iter√°vel.

# Por√©m, √†s vezes, pode acontecer de voc√™ querer uma vari√°vel que muda em cada itera√ß√£o do loop. 
# Em vez de criar e incrementar uma vari√°vel voc√™ mesmo, voc√™ pode usar enumerate() do Python para 
# obter um contador e o valor do iter√°vel ao mesmo tempo!

languages = ['Python', 'Java', 'JavaScript']

enumerate_prime = enumerate(languages)

# converte um objeto enumerate em uma lista
print(list(enumerate_prime))

# Sa√≠da: [(0, 'Python'), (1, 'Java'), (2, 'JavaScript')]

# Voc√™ tamb√©m pode desestruturar (unpack) os itens da lista ou tupla:

languages = ['Python', 'Java', 'JavaScript']

for index, language in enumerate(['Python', 'Java']):
    print(f'{index} - {language}')
# Sa√≠da:
# 0 - Python
# 1 - Java


# De olho na dica: na linha 4 voc√™ deve ter reparado algo diferente neste c√≥digo 
# print(f'{index} - {language}'). A letra f usada dentro do print √© chamada de f-string. 
# Ela fornece uma maneira de incorporar express√µes dentro de strings literais, usando uma 
# sintaxe m√≠nima. Lembre-se de ler a documenta√ß√£o em caso de d√∫vidas.


